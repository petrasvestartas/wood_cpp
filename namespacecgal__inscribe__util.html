<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WOOD: cgal_inscribe_util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WOOD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacecgal__inscribe__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cgal_inscribe_util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4371ab1d1ab66869f9d065a2792f5996" id="r_a4371ab1d1ab66869f9d065a2792f5996"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; IK::Point_3, IK::Plane_3, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4371ab1d1ab66869f9d065a2792f5996">get_polylabel</a> (const std::vector&lt; CGAL_Polyline &gt; &amp;polylines, double precision)</td></tr>
<tr class="separator:a4371ab1d1ab66869f9d065a2792f5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f7cad74d94b1ddfcc56077a8e2495" id="r_a3c0f7cad74d94b1ddfcc56077a8e2495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0f7cad74d94b1ddfcc56077a8e2495">get_polylabel_circle_division_points</a> (const IK::Vector_3 &amp;division_direction_in_3d, const std::vector&lt; CGAL_Polyline &gt; &amp;polylines, std::vector&lt; IK::Point_3 &gt; &amp;points, int division, double scale, double precision, bool orient_to_closest_edge)</td></tr>
<tr class="separator:a3c0f7cad74d94b1ddfcc56077a8e2495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589b5ef8355f5386bbd1d24027062e97" id="r_a589b5ef8355f5386bbd1d24027062e97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a589b5ef8355f5386bbd1d24027062e97">inscribe_rectangle_in_convex_polygon</a> (const std::vector&lt; CGAL_Polyline &gt; &amp;polylines, CGAL_Polyline &amp;result, std::vector&lt; IK::Point_3 &gt; &amp;points, IK::Segment_3 &amp;direction, double scale, double precision, double rectangle_division_distance)</td></tr>
<tr class="separator:a589b5ef8355f5386bbd1d24027062e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4371ab1d1ab66869f9d065a2792f5996" name="a4371ab1d1ab66869f9d065a2792f5996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4371ab1d1ab66869f9d065a2792f5996">&#9670;&#160;</a></span>get_polylabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; IK::Point_3, IK::Plane_3, double &gt; cgal_inscribe_util::get_polylabel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CGAL_Polyline &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>inscribe circle in a polygon (with or without holes) the polyline is oriented to XY plane using the input plane then oriented back to 3D a) only the height of the connection volume is taken, not the rectangle b) joints have to be recomputed each time c) intersection between line and elements have to be computed to get a correct line length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polylines</td><td>planar polylines rotated in space </td></tr>
    <tr><td class="paramname">precision</td><td>precision, the smaller the number the less precise the result, default 1.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple that represents the circle (center, plane, radius) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgal__inscribe__util_8cpp_source.html#l00270">270</a> of file <a class="el" href="cgal__inscribe__util_8cpp_source.html">cgal_inscribe_util.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  271</span>    {</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  274</span>        <span class="comment">// copy polylines for orienting from 3D to 2D</span></div>
<div class="line"><span class="lineno">  276</span>        std::vector&lt;CGAL_Polyline&gt; polylines_copy = polylines;</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  279</span>        <span class="comment">// Create Transformation to XY plane</span></div>
<div class="line"><span class="lineno">  281</span>        IK::Point_3 origin;</div>
<div class="line"><span class="lineno">  282</span>        IK::Plane_3 plane;</div>
<div class="line"><span class="lineno">  283</span>        <a class="code hl_function" href="namespacecgal__polyline__util.html#a7166f3ad05d0c38b9729ecdefd3cbd66">cgal_polyline_util::get_fast_plane</a>(polylines_copy[0], origin, plane);</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>        CGAL::Aff_transformation_3&lt;IK&gt; xform_toXY = internal::plane_to_xy(origin, plane);</div>
<div class="line"><span class="lineno">  286</span>        CGAL::Aff_transformation_3&lt;IK&gt; xform_toXY_Inv = xform_toXY.inverse();</div>
<div class="line"><span class="lineno">  287</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;polyline : polylines_copy)</div>
<div class="line"><span class="lineno">  288</span>            <a class="code hl_namespace" href="namespacecgal__polyline__util.html">cgal_polyline_util</a>::transform(polyline, xform_toXY);</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  291</span>        <span class="comment">// Sort polylines based on bounding-box to detect which polylines are holes, this only works if the polygon does not have holes within holes</span></div>
<div class="line"><span class="lineno">  293</span>        std::vector&lt;double&gt; len = std::vector&lt;double&gt;(polylines_copy.size());</div>
<div class="line"><span class="lineno">  294</span>        std::vector&lt;int&gt; ids(len.size());</div>
<div class="line"><span class="lineno">  295</span>        std::iota(begin(ids), end(ids), 0);</div>
<div class="line"><span class="lineno">  296</span> </div>
<div class="line"><span class="lineno">  298</span>        <span class="comment">// Get bounding box length of polylines_copy</span></div>
<div class="line"><span class="lineno">  300</span>        <span class="keywordflow">if</span> (len.size() &gt; 0)</div>
<div class="line"><span class="lineno">  301</span>        {</div>
<div class="line"><span class="lineno">  302</span>            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; polylines_copy.size(); i++)</div>
<div class="line"><span class="lineno">  303</span>            {</div>
<div class="line"><span class="lineno">  304</span>                CGAL::Bbox_3 AABB = CGAL::bbox_3(polylines_copy[i].begin(), polylines_copy[i].end(), IK());</div>
<div class="line"><span class="lineno">  305</span>                <span class="keyword">auto</span> p0 = IK::Point_3(AABB.xmin(), AABB.ymin(), AABB.zmin());</div>
<div class="line"><span class="lineno">  306</span>                <span class="keyword">auto</span> p1 = IK::Point_3(AABB.xmax(), AABB.ymax(), AABB.zmax());</div>
<div class="line"><span class="lineno">  307</span>                len[i] = CGAL::squared_distance(p0, p1);</div>
<div class="line"><span class="lineno">  308</span>            }</div>
<div class="line"><span class="lineno">  310</span>            <span class="comment">// Sort polylines_copy indices by the bounding box length</span></div>
<div class="line"><span class="lineno">  311</span>            <span class="comment">// WARNING orientation is not checked, which should be fine with the Polylabel algorithm</span></div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span>            std::vector&lt;int&gt; ids(len.size());</div>
<div class="line"><span class="lineno">  315</span>            std::sort(begin(ids), end(ids), [&amp;](<span class="keywordtype">int</span> ia, <span class="keywordtype">int</span> ib)</div>
<div class="line"><span class="lineno">  316</span>                      { <span class="keywordflow">return</span> len[ia] &lt; len[ib]; });</div>
<div class="line"><span class="lineno">  317</span>            std::reverse(begin(ids), end(ids));</div>
<div class="line"><span class="lineno">  318</span>        }</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  321</span>        <span class="comment">// Convert polylines_copy to Polylabel datastructure, be aware that the polyline considers all polygons closed, so skip the last point</span></div>
<div class="line"><span class="lineno">  323</span>        mapbox::geometry::polygon&lt;double&gt; polygon_with_holes(polylines_copy.size());</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; polylines_copy.size(); i++)</div>
<div class="line"><span class="lineno">  326</span>        {</div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; polylines_copy[ids[i]].size() - 1; j++)</div>
<div class="line"><span class="lineno">  328</span>            {</div>
<div class="line"><span class="lineno">  329</span>                polygon_with_holes[i].emplace_back(polylines_copy[ids[i]][j].x(), polylines_copy[ids[i]][j].y());</div>
<div class="line"><span class="lineno">  330</span>                <span class="comment">// std::cout &lt;&lt; polylines_copy[ids[i]][j].x() &lt;&lt; &quot; &quot; &lt;&lt; polylines_copy[ids[i]][j].y() &lt;&lt; std::endl;</span></div>
<div class="line"><span class="lineno">  331</span>            }</div>
<div class="line"><span class="lineno">  332</span>        }</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  335</span>        <span class="comment">// Run the Polylabel algorithm, WARNING numbers are in 2D, first two doubles are center, the third is the radius</span></div>
<div class="line"><span class="lineno">  337</span>        std::array&lt;double, 3&gt; center_and_radius = mapbox::polylabel(polygon_with_holes, 1.0);</div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="comment">// Convert from the Polylabel datastructure to CGAL</span></div>
<div class="line"><span class="lineno">  342</span>        IK::Point_3 <a class="code hl_function" href="namespacecgal__polyline__util.html#a558b3d330cc1345285bb26618381e3e7">center</a>(center_and_radius[0], center_and_radius[1], 0);</div>
<div class="line"><span class="lineno">  343</span>        <a class="code hl_function" href="namespacecgal__polyline__util.html#a558b3d330cc1345285bb26618381e3e7">center</a> = <a class="code hl_function" href="namespacecgal__polyline__util.html#a558b3d330cc1345285bb26618381e3e7">center</a>.transform(xform_toXY_Inv);</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="comment">// Output</span></div>
<div class="line"><span class="lineno">  348</span>        <span class="keywordflow">return</span> std::tuple&lt;IK::Point_3, IK::Plane_3, double&gt;(center, plane, center_and_radius[2]);</div>
<div class="line"><span class="lineno">  349</span>    }</div>
<div class="ttc" id="anamespacecgal__polyline__util_html"><div class="ttname"><a href="namespacecgal__polyline__util.html">cgal_polyline_util</a></div><div class="ttdef"><b>Definition</b> <a href="cgal__polyline__util_8cpp_source.html#l00006">cgal_polyline_util.cpp:7</a></div></div>
<div class="ttc" id="anamespacecgal__polyline__util_html_a558b3d330cc1345285bb26618381e3e7"><div class="ttname"><a href="namespacecgal__polyline__util.html#a558b3d330cc1345285bb26618381e3e7">cgal_polyline_util::center</a></div><div class="ttdeci">IK::Point_3 center(const CGAL_Polyline &amp;polyline)</div><div class="ttdef"><b>Definition</b> <a href="cgal__polyline__util_8cpp_source.html#l00291">cgal_polyline_util.cpp:291</a></div></div>
<div class="ttc" id="anamespacecgal__polyline__util_html_a7166f3ad05d0c38b9729ecdefd3cbd66"><div class="ttname"><a href="namespacecgal__polyline__util.html#a7166f3ad05d0c38b9729ecdefd3cbd66">cgal_polyline_util::get_fast_plane</a></div><div class="ttdeci">void get_fast_plane(const CGAL_Polyline &amp;polyline, IK::Point_3 &amp;origin, IK::Plane_3 &amp;plane)</div><div class="ttdef"><b>Definition</b> <a href="cgal__polyline__util_8cpp_source.html#l00349">cgal_polyline_util.cpp:349</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c0f7cad74d94b1ddfcc56077a8e2495" name="a3c0f7cad74d94b1ddfcc56077a8e2495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0f7cad74d94b1ddfcc56077a8e2495">&#9670;&#160;</a></span>get_polylabel_circle_division_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgal_inscribe_util::get_polylabel_circle_division_points </td>
          <td>(</td>
          <td class="paramtype">const IK::Vector_3 &amp;</td>          <td class="paramname"><span class="paramname"><em>division_direction_in_3d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CGAL_Polyline &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IK::Point_3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>division</em><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em><span class="paramdefsep"> = </span><span class="paramdefval">0.75</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orient_to_closest_edge</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get points inscribed in a polylable circle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">division_direction_in_3d</td><td>division direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polylines</td><td>list of polylines that representes the input polylines for the polylabel algorithm </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>division points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">division</td><td>number of points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>scale of the circle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>tolerance for the polylabel algorithm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orient_to_closest_edge</td><td>if true, the points are oriented to the closest edge </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cgal__inscribe__util_8cpp_source.html#l00351">351</a> of file <a class="el" href="cgal__inscribe__util_8cpp_source.html">cgal_inscribe_util.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  352</span>    {</div>
<div class="line"><span class="lineno">  353</span>        <span class="comment">// run the polylabel algorithm</span></div>
<div class="line"><span class="lineno">  354</span>        std::tuple&lt;IK::Point_3, IK::Plane_3, double&gt; circle = <a class="code hl_function" href="#a4371ab1d1ab66869f9d065a2792f5996">get_polylabel</a>(polylines, precision);</div>
<div class="line"><span class="lineno">  355</span>        IK::Vector_3 center(std::get&lt;0&gt;(circle).hx(), std::get&lt;0&gt;(circle).hy(), std::get&lt;0&gt;(circle).hz());</div>
<div class="line"><span class="lineno">  356</span>        <span class="keywordtype">bool</span> is_direction_valid = division_direction_in_3d.hx() != 0.0 &amp;&amp; division_direction_in_3d.hy() != 0.0 &amp;&amp; division_direction_in_3d.hz() != 0.0;</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  359</span>        <span class="comment">// Find closest edge direction to the center</span></div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>        IK::Point_3 center_point(std::get&lt;0&gt;(circle).hx(), std::get&lt;0&gt;(circle).hy(), std::get&lt;0&gt;(circle).hz());</div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordtype">double</span> distance_from_center_to_polyline_edge = DBL_MAX;</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordtype">size_t</span> edge_id0 = 0;</div>
<div class="line"><span class="lineno">  365</span>        <span class="keywordtype">size_t</span> edge_id1 = 0;</div>
<div class="line"><span class="lineno">  366</span>        <span class="keywordflow">if</span> (orient_to_closest_edge)</div>
<div class="line"><span class="lineno">  367</span>        {</div>
<div class="line"><span class="lineno">  368</span> </div>
<div class="line"><span class="lineno">  369</span>            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; polylines.size(); i++)</div>
<div class="line"><span class="lineno">  370</span>            {</div>
<div class="line"><span class="lineno">  371</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; polylines[i].size() - 1; j++)</div>
<div class="line"><span class="lineno">  372</span>                {</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>                    IK::Segment_3 polyline_segment(polylines[i][j], polylines[i][j + 1]);</div>
<div class="line"><span class="lineno">  375</span>                    IK::Point_3 projection = polyline_segment.supporting_line().projection(center_point);</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>                    <span class="comment">// closest point paraneters</span></div>
<div class="line"><span class="lineno">  378</span>                    <span class="keywordtype">bool</span> has_on = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  379</span>                    <span class="keyword">const</span> IK::Vector_3 polyline_segment_vector = polyline_segment.to_vector();</div>
<div class="line"><span class="lineno">  380</span>                    <span class="keyword">const</span> <span class="keywordtype">double</span> polyline_segment_vector_squared_len = polyline_segment_vector.squared_length();</div>
<div class="line"><span class="lineno">  381</span>                    <span class="keywordtype">double</span> t = 0;</div>
<div class="line"><span class="lineno">  382</span> </div>
<div class="line"><span class="lineno">  383</span>                    <span class="keywordflow">if</span> (polyline_segment_vector.squared_length() &gt; 0.0)</div>
<div class="line"><span class="lineno">  384</span>                    {</div>
<div class="line"><span class="lineno">  385</span>                        <span class="keywordflow">if</span> ((projection - polyline_segment[0]).squared_length() &lt;= (projection - polyline_segment[1]).squared_length())</div>
<div class="line"><span class="lineno">  386</span>                            t = ((projection - polyline_segment[0]) * polyline_segment_vector) / polyline_segment_vector_squared_len;</div>
<div class="line"><span class="lineno">  387</span>                        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  388</span>                            t = 1.0 + ((projection - polyline_segment[1]) * polyline_segment_vector) / polyline_segment_vector_squared_len;</div>
<div class="line"><span class="lineno">  389</span> </div>
<div class="line"><span class="lineno">  390</span>                        has_on = t &gt;= 0 &amp;&amp; t &lt;= 1;</div>
<div class="line"><span class="lineno">  391</span>                    }</div>
<div class="line"><span class="lineno">  392</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  393</span>                    { <span class="comment">// (GBA) Closest point to a degenerate line works as well</span></div>
<div class="line"><span class="lineno">  394</span>                        t = 0.0;</div>
<div class="line"><span class="lineno">  395</span>                        has_on = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  396</span>                    }</div>
<div class="line"><span class="lineno">  397</span> </div>
<div class="line"><span class="lineno">  398</span>                    <span class="comment">// check if the point is on the edge</span></div>
<div class="line"><span class="lineno">  399</span>                    <span class="keywordflow">if</span> (has_on)</div>
<div class="line"><span class="lineno">  400</span>                    {</div>
<div class="line"><span class="lineno">  401</span>                        <span class="keywordtype">double</span> temp_distance_from_center_to_polyline_edge = CGAL::squared_distance(center_point, projection);</div>
<div class="line"><span class="lineno">  402</span>                        <span class="keywordflow">if</span> (temp_distance_from_center_to_polyline_edge &lt; distance_from_center_to_polyline_edge)</div>
<div class="line"><span class="lineno">  403</span>                        {</div>
<div class="line"><span class="lineno">  404</span>                            distance_from_center_to_polyline_edge = temp_distance_from_center_to_polyline_edge;</div>
<div class="line"><span class="lineno">  405</span>                            edge_id0 = i;</div>
<div class="line"><span class="lineno">  406</span>                            edge_id1 = j;</div>
<div class="line"><span class="lineno">  407</span>                        }</div>
<div class="line"><span class="lineno">  408</span>                    }</div>
<div class="line"><span class="lineno">  409</span>                }</div>
<div class="line"><span class="lineno">  410</span>            }</div>
<div class="line"><span class="lineno">  411</span>        }</div>
<div class="line"><span class="lineno">  412</span> </div>
<div class="line"><span class="lineno">  413</span>        <span class="comment">// orientation direction</span></div>
<div class="line"><span class="lineno">  414</span>        IK::Vector_3 division_direction_in_3d_ = orient_to_closest_edge ? polylines[edge_id0][edge_id1 + 1] - polylines[edge_id0][edge_id1 + 0] : IK::Vector_3(division_direction_in_3d.hx(), division_direction_in_3d.hy(), division_direction_in_3d.hz());</div>
<div class="line"><span class="lineno">  415</span> </div>
<div class="line"><span class="lineno">  416</span>        <span class="comment">// plane vectors for orienting again to 2d for circle points dvisions</span></div>
<div class="line"><span class="lineno">  417</span>        IK::Vector_3 x_axis = is_direction_valid || orient_to_closest_edge ? division_direction_in_3d_ : std::get&lt;1&gt;(circle).base1();</div>
<div class="line"><span class="lineno">  418</span>        IK::Vector_3 y_axis = is_direction_valid || orient_to_closest_edge ? CGAL::cross_product(division_direction_in_3d_, std::get&lt;1&gt;(circle).orthogonal_vector()) : std::get&lt;1&gt;(circle).base2();</div>
<div class="line"><span class="lineno">  419</span>        IK::Vector_3 z_axis = std::get&lt;1&gt;(circle).orthogonal_vector();</div>
<div class="line"><span class="lineno">  420</span> </div>
<div class="line"><span class="lineno">  421</span>        <span class="comment">// run the division method which is the output -&gt; points</span></div>
<div class="line"><span class="lineno">  422</span>        internal::circle_points(center, x_axis, y_axis, z_axis, points, division, std::get&lt;2&gt;(circle) * scale);</div>
<div class="line"><span class="lineno">  423</span>    }</div>
<div class="ttc" id="anamespacecgal__inscribe__util_html_a4371ab1d1ab66869f9d065a2792f5996"><div class="ttname"><a href="#a4371ab1d1ab66869f9d065a2792f5996">cgal_inscribe_util::get_polylabel</a></div><div class="ttdeci">std::tuple&lt; IK::Point_3, IK::Plane_3, double &gt; get_polylabel(const std::vector&lt; CGAL_Polyline &gt; &amp;polylines, double precision)</div><div class="ttdef"><b>Definition</b> <a href="cgal__inscribe__util_8cpp_source.html#l00270">cgal_inscribe_util.cpp:270</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a589b5ef8355f5386bbd1d24027062e97" name="a589b5ef8355f5386bbd1d24027062e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589b5ef8355f5386bbd1d24027062e97">&#9670;&#160;</a></span>inscribe_rectangle_in_convex_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgal_inscribe_util::inscribe_rectangle_in_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CGAL_Polyline &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polylines</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL_Polyline &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IK::Point_3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IK::Segment_3 &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rectangle_division_distance</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>iscribe ractangle in a polygon and divide its edges into points or create rectangle grid <a href="https://doc.cgal.org/latest/Inscribed_areas/index.html">https://doc.cgal.org/latest/Inscribed_areas/index.html</a> also a good reference that could be implemented in a separate method: <a href="https://github.com/mo42/ler">https://github.com/mo42/ler</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polylines</td><td>input polylines (with holes) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>output rectangle inscribed between division points of the polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">points</td><td>output division points hwne </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>segment in 3D that represents the orientation of the rectangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>the rectangle scale, since the algorithm works with points, it never returns the exact touching with the edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>numeric parameters that subdivide more or less points of the polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rectangle_division_distance</td><td>when division distance is below 0, the rectangle grid is cretead, if above, the rectangle's edges are subdivided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool flag if the result is valid </dd></dl>

<p class="definition">Definition at line <a class="el" href="cgal__inscribe__util_8cpp_source.html#l00425">425</a> of file <a class="el" href="cgal__inscribe__util_8cpp_source.html">cgal_inscribe_util.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  426</span>    {</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  429</span>        <span class="comment">// copy polylines</span></div>
<div class="line"><span class="lineno">  431</span>        std::vector&lt;CGAL_Polyline&gt; polylines_copy = polylines;</div>
<div class="line"><span class="lineno">  432</span> </div>
<div class="line"><span class="lineno">  434</span>        <span class="comment">// user direction</span></div>
<div class="line"><span class="lineno">  436</span> </div>
<div class="line"><span class="lineno">  437</span>        IK::Point_3 o;</div>
<div class="line"><span class="lineno">  438</span>        IK::Vector_3 x, y, z;</div>
<div class="line"><span class="lineno">  439</span>        <span class="keywordflow">if</span> (direction.squared_length() &gt; <a class="code hl_variable" href="namespacewood__globals.html#a4829ca446b4f022ee5c396fde5fbcfb9">wood_globals::DISTANCE_SQUARED</a>)</div>
<div class="line"><span class="lineno">  440</span>        {</div>
<div class="line"><span class="lineno">  441</span> </div>
<div class="line"><span class="lineno">  442</span>            internal::get_fast_plane(polylines_copy[0], o, x, y, z);</div>
<div class="line"><span class="lineno">  443</span>            x = direction.to_vector();</div>
<div class="line"><span class="lineno">  444</span>            y = CGAL::cross_product(x, z);</div>
<div class="line"><span class="lineno">  445</span>        }</div>
<div class="line"><span class="lineno">  446</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  447</span>        {</div>
<div class="line"><span class="lineno">  448</span>            <span class="comment">// this was never checked</span></div>
<div class="line"><span class="lineno">  449</span>            internal::get_average_plane_axes_oriented_to_longest_edge(polylines_copy[0], o, x, y, z);</div>
<div class="line"><span class="lineno">  450</span>        }</div>
<div class="line"><span class="lineno">  451</span> </div>
<div class="line"><span class="lineno">  452</span>        <span class="comment">// if (polylines_copy[0].size() != 5)</span></div>
<div class="line"><span class="lineno">  453</span>        <span class="comment">//     return true;</span></div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  456</span>        <span class="comment">// Create Transformation to XY plane</span></div>
<div class="line"><span class="lineno">  458</span>        CGAL::Aff_transformation_3&lt;IK&gt;</div>
<div class="line"><span class="lineno">  459</span>            xform_toXY = internal::plane_to_xy(o, x, y, z);</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>        <span class="comment">// without rotation the algorithm does not work, is it a bug of CGAL?</span></div>
<div class="line"><span class="lineno">  462</span>        CGAL::Aff_transformation_3&lt;IK&gt; rot = internal::axis_rotation(0.0001, IK::Vector_3(0, 0, 1));</div>
<div class="line"><span class="lineno">  463</span>        xform_toXY = rot * xform_toXY;</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>        CGAL::Aff_transformation_3&lt;IK&gt;</div>
<div class="line"><span class="lineno">  466</span>            xform_toXY_Inv = xform_toXY.inverse();</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  469</span>        <span class="comment">// Count how many points we have</span></div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordtype">size_t</span> point_count = 0;</div>
<div class="line"><span class="lineno">  472</span> </div>
<div class="line"><span class="lineno">  473</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;polyline : polylines_copy)</div>
<div class="line"><span class="lineno">  474</span>            point_count += polyline.size();</div>
<div class="line"><span class="lineno">  475</span> </div>
<div class="line"><span class="lineno">  477</span>        <span class="comment">// Compute 2D bounding box to get a division step, the division step is equal to = diagonal_length/(20*precision)</span></div>
<div class="line"><span class="lineno">  479</span>        std::vector&lt;IK::Point_2&gt; points_2d;</div>
<div class="line"><span class="lineno">  480</span>        points_2d.reserve(point_count);</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;polyline : polylines_copy)</div>
<div class="line"><span class="lineno">  483</span>        {</div>
<div class="line"><span class="lineno">  484</span>            <a class="code hl_function" href="namespacecgal__polyline__util.html#a4d0ef4fe8f237dc96f9c56cf63f6ace5">cgal_polyline_util::transform</a>(polyline, xform_toXY);</div>
<div class="line"><span class="lineno">  485</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : polyline)</div>
<div class="line"><span class="lineno">  486</span>                points_2d.push_back(IK::Point_2(p.hx(), p.hy()));</div>
<div class="line"><span class="lineno">  487</span>            points_2d.pop_back();</div>
<div class="line"><span class="lineno">  488</span>        }</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        CGAL::Bbox_2 bbox = CGAL::bbox_2(points_2d.begin(), points_2d.end(), IK());</div>
<div class="line"><span class="lineno">  491</span>        <span class="keyword">auto</span> diagonal = {IK::Point_3(bbox.xmin(), bbox.ymin(), 0), IK::Point_3(bbox.xmax(), bbox.ymax(), 0)};</div>
<div class="line"><span class="lineno">  492</span>        <span class="keywordtype">double</span> squared_diagonal_length = CGAL::squared_distance(IK::Point_3(bbox.xmin(), bbox.ymin(), 0), IK::Point_3(bbox.xmax(), bbox.ymax(), 0));</div>
<div class="line"><span class="lineno">  493</span>        <span class="keywordtype">double</span> step_division = std::sqrt(squared_diagonal_length) / (50.0 * precision);</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  496</span>        <span class="comment">// Get iso rectangle as the first input for the algorithm</span></div>
<div class="line"><span class="lineno">  498</span>        IK::Iso_rectangle_2 bbox_rectangle(bbox);</div>
<div class="line"><span class="lineno">  499</span>        CGAL::Largest_empty_iso_rectangle_2&lt;IK&gt; empty_rect(bbox_rectangle);</div>
<div class="line"><span class="lineno">  500</span> </div>
<div class="line"><span class="lineno">  502</span>        <span class="comment">// Interpolate edge points in by the precomputed division step</span></div>
<div class="line"><span class="lineno">  504</span> </div>
<div class="line"><span class="lineno">  505</span>        CGAL_Polyline division_points;</div>
<div class="line"><span class="lineno">  506</span>        CGAL_Polyline division_points_temp;</div>
<div class="line"><span class="lineno">  507</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;polyline : polylines_copy)</div>
<div class="line"><span class="lineno">  508</span>            for (int i = 0; i &lt; polyline.size() - 1; i++)</div>
<div class="line"><span class="lineno">  509</span>            {</div>
<div class="line"><span class="lineno">  510</span>                division_points.clear();</div>
<div class="line"><span class="lineno">  511</span>                <span class="keywordtype">int</span> divisions = (int)std::min(100.0, std::sqrt(CGAL::squared_distance(polyline[i], polyline[i + 1])) / step_division);</div>
<div class="line"><span class="lineno">  512</span>                <a class="code hl_function" href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a>(polyline[i], polyline[i + 1], divisions, division_points, 2);</div>
<div class="line"><span class="lineno">  513</span>                division_points_temp.insert(division_points_temp.end(), division_points.begin(), division_points.end());</div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;point : division_points)</div>
<div class="line"><span class="lineno">  516</span>                {</div>
<div class="line"><span class="lineno">  517</span>                    empty_rect.push_back(IK::Point_2(point.hx(), point.hy()));</div>
<div class="line"><span class="lineno">  518</span>                }</div>
<div class="line"><span class="lineno">  519</span>            }</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  522</span>        <span class="comment">// Get the largest empty iso rectangle</span></div>
<div class="line"><span class="lineno">  524</span>        IK::Iso_rectangle_2 rectangle = empty_rect.get_largest_empty_iso_rectangle();</div>
<div class="line"><span class="lineno">  525</span>        <span class="keywordtype">double</span> x_dist = (1 - <a class="code hl_variable" href="namespaceviewer__wood.html#a35a35d5d375e5681345d05c5a1db59b5">scale</a>) * std::abs(rectangle.max().hx() - rectangle.min().hx());</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordtype">double</span> y_dist = (1 - <a class="code hl_variable" href="namespaceviewer__wood.html#a35a35d5d375e5681345d05c5a1db59b5">scale</a>) * std::abs(rectangle.max().hy() - rectangle.min().hy());</div>
<div class="line"><span class="lineno">  527</span>        x_dist = std::min(x_dist, y_dist);</div>
<div class="line"><span class="lineno">  528</span>        y_dist = x_dist;</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>        CGAL_Polyline rect = {</div>
<div class="line"><span class="lineno">  531</span>            IK::Point_3(rectangle.min().hx() + x_dist, rectangle.min().hy() + y_dist, 0),</div>
<div class="line"><span class="lineno">  532</span>            IK::Point_3(rectangle.min().hx() + x_dist, rectangle.max().hy() - y_dist, 0),</div>
<div class="line"><span class="lineno">  533</span>            IK::Point_3(rectangle.max().hx() - x_dist, rectangle.max().hy() - y_dist, 0),</div>
<div class="line"><span class="lineno">  534</span>            IK::Point_3(rectangle.max().hx() - x_dist, rectangle.min().hy() + y_dist, 0),</div>
<div class="line"><span class="lineno">  535</span>            IK::Point_3(rectangle.min().hx() + x_dist, rectangle.min().hy() + y_dist, 0),</div>
<div class="line"><span class="lineno">  536</span>        };</div>
<div class="line"><span class="lineno">  537</span> </div>
<div class="line"><span class="lineno">  539</span>        <span class="comment">// Orient Back to 3D</span></div>
<div class="line"><span class="lineno">  541</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;point : rect)</div>
<div class="line"><span class="lineno">  542</span>            point = point.<a class="code hl_function" href="namespacecgal__polyline__util.html#a4d0ef4fe8f237dc96f9c56cf63f6ace5">transform</a>(xform_toXY_Inv);</div>
<div class="line"><span class="lineno">  543</span> </div>
<div class="line"><span class="lineno">  545</span>        <span class="comment">// point on the edge of the rectangle or division of points inside the rectangle</span></div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">if</span> (rectangle_division_distance &gt; <a class="code hl_variable" href="namespacewood__globals.html#acb060d97a15f21abd66a15b6a5fd8582">wood_globals::DISTANCE</a>)</div>
<div class="line"><span class="lineno">  548</span>        {</div>
<div class="line"><span class="lineno">  550</span>            <span class="comment">// divide edges by distance</span></div>
<div class="line"><span class="lineno">  552</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rect.size() - 1; i++)</div>
<div class="line"><span class="lineno">  553</span>            {</div>
<div class="line"><span class="lineno">  554</span>                division_points.clear();</div>
<div class="line"><span class="lineno">  555</span>                <span class="keywordtype">int</span> divisions = (int)std::min(25.0, std::sqrt(CGAL::squared_distance(rect[i], rect[i + 1])) / rectangle_division_distance);</div>
<div class="line"><span class="lineno">  556</span>                <a class="code hl_function" href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a>(rect[i], rect[i + 1], divisions, division_points, 2);</div>
<div class="line"><span class="lineno">  557</span>                points.insert(points.end(), division_points.begin(), division_points.end());</div>
<div class="line"><span class="lineno">  558</span>            }</div>
<div class="line"><span class="lineno">  559</span>            <span class="comment">// cgal_polyline_util::transform(division_points_temp, xform_toXY_Inv);</span></div>
<div class="line"><span class="lineno">  560</span>            <span class="comment">// points.clear();</span></div>
<div class="line"><span class="lineno">  561</span>            <span class="comment">// points.insert(points.end(), division_points_temp.begin(), division_points_temp.end());</span></div>
<div class="line"><span class="lineno">  562</span>            <span class="comment">//  auto p0_min = (IK::Point_3(bbox.xmin(), bbox.ymin(), 0)).transform(xform_toXY_Inv);</span></div>
<div class="line"><span class="lineno">  563</span>            <span class="comment">//  auto p0_max = (IK::Point_3(bbox.xmax(), bbox.ymax(), 0)).transform(xform_toXY_Inv);</span></div>
<div class="line"><span class="lineno">  564</span>            <span class="comment">//  points.emplace_back(p0_min);</span></div>
<div class="line"><span class="lineno">  565</span>            <span class="comment">//  points.emplace_back(p0_max);</span></div>
<div class="line"><span class="lineno">  566</span>        }</div>
<div class="line"><span class="lineno">  567</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rectangle_division_distance &lt; -<a class="code hl_variable" href="namespacewood__globals.html#acb060d97a15f21abd66a15b6a5fd8582">wood_globals::DISTANCE</a>)</div>
<div class="line"><span class="lineno">  568</span>        {</div>
<div class="line"><span class="lineno">  570</span>            <span class="comment">// get divisions of each edge and take the smallest division</span></div>
<div class="line"><span class="lineno">  572</span>            <span class="keywordtype">double</span> unsigned_rectangle_division_distance = std::abs(rectangle_division_distance);</div>
<div class="line"><span class="lineno">  573</span>            <span class="keywordtype">double</span> edge_dist_00 = std::sqrt(CGAL::squared_distance(rect[0], rect[1]));</div>
<div class="line"><span class="lineno">  574</span>            <span class="keywordtype">double</span> edge_dist_01 = std::sqrt(CGAL::squared_distance(rect[3], rect[2]));</div>
<div class="line"><span class="lineno">  575</span>            <span class="keywordtype">double</span> edge_dist_10 = std::sqrt(CGAL::squared_distance(rect[1], rect[2]));</div>
<div class="line"><span class="lineno">  576</span>            <span class="keywordtype">double</span> edge_dist_11 = std::sqrt(CGAL::squared_distance(rect[0], rect[3]));</div>
<div class="line"><span class="lineno">  577</span> </div>
<div class="line"><span class="lineno">  578</span>            <span class="keywordtype">int</span> divisions_u = (int)(std::min(std::ceil(edge_dist_00 / unsigned_rectangle_division_distance), std::ceil(edge_dist_01 / unsigned_rectangle_division_distance)));</div>
<div class="line"><span class="lineno">  579</span>            <span class="keywordtype">int</span> divisions_v = (int)(std::min(std::ceil(edge_dist_10 / unsigned_rectangle_division_distance), std::ceil(edge_dist_11 / unsigned_rectangle_division_distance)));</div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="line"><span class="lineno">  582</span>            <span class="comment">// divide two edges into divisions points and then interpolate these points</span></div>
<div class="line"><span class="lineno">  584</span>            std::vector&lt;IK::Point_3&gt; division_points_edge_0, division_points_edge_2;</div>
<div class="line"><span class="lineno">  585</span>            division_points_edge_0.reserve(divisions_u);</div>
<div class="line"><span class="lineno">  586</span>            division_points_edge_2.reserve(divisions_v);</div>
<div class="line"><span class="lineno">  587</span>            <a class="code hl_function" href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a>(rect[0], rect[1], divisions_u, division_points_edge_0, 1);</div>
<div class="line"><span class="lineno">  588</span>            <a class="code hl_function" href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a>(rect[3], rect[2], divisions_u, division_points_edge_2, 1);</div>
<div class="line"><span class="lineno">  589</span> </div>
<div class="line"><span class="lineno">  590</span>            points.reserve((divisions_u + 2) * (divisions_v + 2));</div>
<div class="line"><span class="lineno">  591</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (divisions_u + 2); i++)</div>
<div class="line"><span class="lineno">  592</span>            {</div>
<div class="line"><span class="lineno">  593</span>                std::vector&lt;IK::Point_3&gt; temp_divisions;</div>
<div class="line"><span class="lineno">  594</span>                <a class="code hl_function" href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a>(division_points_edge_0[i], division_points_edge_2[i], divisions_v, temp_divisions, 1);</div>
<div class="line"><span class="lineno">  595</span>                points.insert(points.end(), temp_divisions.begin(), temp_divisions.end());</div>
<div class="line"><span class="lineno">  596</span>            }</div>
<div class="line"><span class="lineno">  597</span>        }</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  600</span>        <span class="comment">// Output</span></div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        result = rect;</div>
<div class="line"><span class="lineno">  604</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  605</span>    }</div>
<div class="ttc" id="anamespacecgal__polyline__util_html_a4d0ef4fe8f237dc96f9c56cf63f6ace5"><div class="ttname"><a href="namespacecgal__polyline__util.html#a4d0ef4fe8f237dc96f9c56cf63f6ace5">cgal_polyline_util::transform</a></div><div class="ttdeci">void transform(CGAL_Polyline &amp;polyline, const CGAL::Aff_transformation_3&lt; IK &gt; &amp;transform)</div><div class="ttdef"><b>Definition</b> <a href="cgal__polyline__util_8cpp_source.html#l00327">cgal_polyline_util.cpp:327</a></div></div>
<div class="ttc" id="anamespacecgal__vector__util_html_a359fbb18a7e060a4af56455ba0b20aeb"><div class="ttname"><a href="namespacecgal__vector__util.html#a359fbb18a7e060a4af56455ba0b20aeb">cgal_vector_util::interpolate_points</a></div><div class="ttdeci">void interpolate_points(const IK::Point_3 &amp;from, const IK::Point_3 &amp;to, const int &amp;steps, std::vector&lt; IK::Point_3 &gt; &amp;points, int type_0_noends_1_end_2_oneend)</div><div class="ttdef"><b>Definition</b> <a href="cgal__vector__util_8cpp_source.html#l00142">cgal_vector_util.cpp:142</a></div></div>
<div class="ttc" id="anamespaceviewer__wood_html_a35a35d5d375e5681345d05c5a1db59b5"><div class="ttname"><a href="namespaceviewer__wood.html#a35a35d5d375e5681345d05c5a1db59b5">viewer_wood::scale</a></div><div class="ttdeci">float scale</div><div class="ttdef"><b>Definition</b> <a href="viewer__wood_8cpp_source.html#l00006">viewer_wood.cpp:6</a></div></div>
<div class="ttc" id="anamespacewood__globals_html_a4829ca446b4f022ee5c396fde5fbcfb9"><div class="ttname"><a href="namespacewood__globals.html#a4829ca446b4f022ee5c396fde5fbcfb9">wood_globals::DISTANCE_SQUARED</a></div><div class="ttdeci">double DISTANCE_SQUARED</div><div class="ttdef"><b>Definition</b> <a href="wood__globals_8cpp_source.html#l00014">wood_globals.cpp:14</a></div></div>
<div class="ttc" id="anamespacewood__globals_html_acb060d97a15f21abd66a15b6a5fd8582"><div class="ttname"><a href="namespacewood__globals.html#acb060d97a15f21abd66a15b6a5fd8582">wood_globals::DISTANCE</a></div><div class="ttdeci">double DISTANCE</div><div class="ttdef"><b>Definition</b> <a href="wood__globals_8cpp_source.html#l00013">wood_globals.cpp:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgal__inscribe__util.html">cgal_inscribe_util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
